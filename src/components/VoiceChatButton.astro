---
// VoiceChatButton component for Vapi integration
// Users need to set their VAPI_PUBLIC_KEY and VAPI_ASSISTANT_ID
// These can be set as environment variables or passed as props
interface Props {
  publicKey?: string;
  assistantId?: string;
  position?: "bottom-right" | "bottom-left" | "top-right" | "top-left";
}

const {
  publicKey = import.meta.env.PUBLIC_VAPI_PUBLIC_KEY || "",
  assistantId = import.meta.env.PUBLIC_VAPI_ASSISTANT_ID || "",
  position = "bottom-right",
} = Astro.props;

const positionClasses = {
  "bottom-right": "bottom-right",
  "bottom-left": "bottom-left",
  "top-right": "top-right",
  "top-left": "top-left",
};
---

<div
  id="vapi-widget-container"
  class={`vapi-widget-container ${positionClasses[position]}`}
>
  <button
    id="vapi-voice-button"
    class="vapi-voice-button"
    aria-label="Start voice chat"
    title="Click to speak with our AI assistant"
  >
    <svg
      class="vapi-icon"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <!-- Question mark icon (default state) -->
      <g id="question-icon" class="icon-default">
        <text
          x="12"
          y="16"
          font-family="Arial, sans-serif"
          font-size="16"
          font-weight="bold"
          fill="currentColor"
          text-anchor="middle"
          dominant-baseline="middle">?</text
        >
      </g>

      <!-- Microphone icon (active/listening state) -->
      <g id="mic-icon" class="icon-active" style="display: none;">
        <path
          d="M12 1C10.34 1 9 2.34 9 4V12C9 13.66 10.34 15 12 15C13.66 15 15 13.66 15 12V4C15 2.34 13.66 1 12 1Z"
          stroke="currentColor"
          stroke-width="2"
          fill="none"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
        <path
          d="M19 10V12C19 16.42 15.42 20 11 20H10C5.58 20 2 16.42 2 12V10"
          stroke="currentColor"
          stroke-width="2"
          fill="none"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
        <path
          d="M12 19V23"
          stroke="currentColor"
          stroke-width="2"
          fill="none"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
        <path
          d="M8 23H16"
          stroke="currentColor"
          stroke-width="2"
          fill="none"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
      </g>
    </svg>
    <span class="vapi-pulse"></span>
  </button>

  <!-- Audio level meter -->
  <div id="audio-level-meter" class="audio-level-meter" style="display: none;">
    <div class="level-bars">
      <div class="level-bar" style="--delay: 0ms"></div>
      <div class="level-bar" style="--delay: 50ms"></div>
      <div class="level-bar" style="--delay: 100ms"></div>
      <div class="level-bar" style="--delay: 150ms"></div>
      <div class="level-bar" style="--delay: 200ms"></div>
    </div>
  </div>
</div>

<script define:vars={{ publicKey, assistantId }}>
  // Vapi SDK will be attached to window.Vapi
  console.log("Vapi credentials check:", {
    publicKey: publicKey ? "***" + publicKey.slice(-4) : "MISSING",
    assistantId: assistantId ? assistantId : "MISSING",
    publicKeyLength: publicKey?.length || 0,
    assistantIdLength: assistantId?.length || 0,
  });

  if (!publicKey || !assistantId) {
    console.warn(
      "Vapi credentials not found. Please set PUBLIC_VAPI_PUBLIC_KEY and PUBLIC_VAPI_ASSISTANT_ID environment variables."
    );
  }

  // Lazy load Vapi SDK only when button is clicked (resource optimization)
  let vapiSDKLoaded = false;
  let vapiSDKLoading = false;

  async function loadVapiSDK() {
    const win = window;

    // Return if already loaded
    if (win.Vapi && typeof win.Vapi === "function") {
      return win.Vapi;
    }

    // Return if already loading
    if (vapiSDKLoading) {
      // Wait for loading to complete
      return new Promise((resolve) => {
        const checkInterval = setInterval(() => {
          if (win.Vapi && typeof win.Vapi === "function") {
            clearInterval(checkInterval);
            resolve(win.Vapi);
          } else if (vapiSDKLoaded && !win.Vapi) {
            clearInterval(checkInterval);
            resolve(null);
          }
        }, 100);
      });
    }

    vapiSDKLoading = true;

    try {
      // Try importing from npm package (Vite will bundle it)
      // Use the package name - Vite handles the resolution
      let VapiModule;
      try {
        VapiModule = await import("@vapi-ai/web");
      } catch (localError) {
        // If local import fails (expected in browser), use CDN
        // This is normal - browser scripts can't resolve npm packages directly
        VapiModule = await import(
          "https://cdn.jsdelivr.net/npm/@vapi-ai/web@latest/+esm"
        );
      }

      // Handle CommonJS default export
      let Vapi = VapiModule.default;

      // If default is not a constructor, try other exports
      if (!Vapi || typeof Vapi !== "function") {
        Vapi = VapiModule.Vapi || VapiModule.VapiClient || VapiModule;
      }

      // Final check - if still not a function, it might be wrapped
      if (!Vapi || typeof Vapi !== "function") {
        // Try accessing the constructor property if it exists
        if (VapiModule.default && VapiModule.default.default) {
          Vapi = VapiModule.default.default;
        }
      }

      // Check if it's actually a constructor
      if (Vapi && typeof Vapi === "function") {
        win.Vapi = Vapi;
        vapiSDKLoaded = true;
        vapiSDKLoading = false;
        return Vapi;
      } else {
        console.error("Vapi module structure:", VapiModule);
        throw new Error(
          "Vapi is not a constructor. Module type: " + typeof Vapi
        );
      }
    } catch (error) {
      console.error("Failed to load Vapi SDK:", error);
      vapiSDKLoaded = true;
      vapiSDKLoading = false;
      return null;
    }
  }

  // Audio level analyzer
  let audioContext = null;
  let analyser = null;
  let microphone = null;
  let dataArray = null;
  let animationFrameId = null;
  let audioStream = null;
  let analyzerActive = false;

  function startAudioAnalyzer(stream) {
    try {
      analyzerActive = true;
      audioStream = stream;
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioContext.createAnalyser();
      microphone = audioContext.createMediaStreamSource(stream);
      microphone.connect(analyser);

      analyser.fftSize = 256;
      const bufferLength = analyser.frequencyBinCount;
      dataArray = new Uint8Array(bufferLength);

      const levelMeter = document.getElementById("audio-level-meter");
      if (levelMeter) {
        levelMeter.style.display = "block";
      }

      function updateLevelMeter() {
        if (!analyser || !analyzerActive) {
          const levelMeter = document.getElementById("audio-level-meter");
          if (levelMeter) {
            levelMeter.style.display = "none";
          }
          return;
        }

        analyser.getByteFrequencyData(dataArray);

        // Calculate average volume level
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += dataArray[i];
        }
        const average = sum / dataArray.length;
        const normalizedLevel = Math.min(average / 128, 1); // Normalize to 0-1

        // Update level bars
        const bars = document.querySelectorAll(".level-bar");
        bars.forEach((bar, index) => {
          // Create a wave effect with different thresholds for each bar
          const threshold = (index + 1) / bars.length;
          const barLevel = Math.max(0, normalizedLevel - (1 - threshold));
          const height = Math.min(barLevel * 100, 100);
          bar.style.height = height + "%";
          bar.style.opacity = height > 5 ? 1 : 0.3;
        });

        animationFrameId = requestAnimationFrame(updateLevelMeter);
      }

      updateLevelMeter();
    } catch (error) {
      console.error("Error starting audio analyzer:", error);
    }
  }

  function stopAudioAnalyzer() {
    analyzerActive = false;

    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }

    if (microphone) {
      try {
        microphone.disconnect();
      } catch (e) {
        // Ignore
      }
      microphone = null;
    }

    if (audioContext && audioContext.state !== "closed") {
      audioContext.close().catch(() => {
        // Ignore errors
      });
      audioContext = null;
    }

    analyser = null;
    dataArray = null;

    const levelMeter = document.getElementById("audio-level-meter");
    if (levelMeter) {
      levelMeter.style.display = "none";
    }

    // Note: Don't stop the stream tracks here - Vapi needs them
    // The stream will be managed by Vapi
    audioStream = null;
  }

  function initializeVapi() {
    const button = document.getElementById("vapi-voice-button");
    if (!button) return;

    let vapiInstance = null;
    let isActive = false;

    // Only add event listener once
    button.addEventListener("click", async function () {
      if (isActive) {
        // Stop the call
        if (vapiInstance) {
          try {
            if (typeof vapiInstance.stop === "function") {
              vapiInstance.stop();
            } else if (typeof vapiInstance.end === "function") {
              vapiInstance.end();
            } else if (typeof vapiInstance.hangup === "function") {
              vapiInstance.hangup();
            }
          } catch (error) {
            console.error("Error stopping call:", error);
          }
          vapiInstance = null;
        }
        isActive = false;
        button.classList.remove("active");
        button.setAttribute("aria-label", "Start voice chat");
        // Switch back to question mark icon
        const questionIcon = document.getElementById("question-icon");
        const micIcon = document.getElementById("mic-icon");
        if (questionIcon) questionIcon.style.display = "block";
        if (micIcon) micIcon.style.display = "none";
        // Stop audio analyzer
        stopAudioAnalyzer();
      } else {
        // Start the call - lazy load SDK here
        try {
          // Show loading state
          button.disabled = true;
          button.style.opacity = "0.7";

          // Load SDK only when needed (resource optimization)
          console.log("Loading Vapi SDK...");
          const Vapi = await loadVapiSDK();
          console.log("Vapi SDK loaded:", !!Vapi);
          console.log("Vapi type:", typeof Vapi);
          console.log("Vapi is function:", typeof Vapi === "function");
          console.log("Vapi is constructor:", typeof Vapi === "function" && Vapi.prototype);

          if (!Vapi || typeof Vapi !== "function") {
            console.error("Vapi SDK validation failed");
            throw new Error("Vapi SDK failed to load or is not a constructor");
          }

          // Request microphone permission and get stream for audio analysis
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });

          // Start audio level analyzer with the stream
          startAudioAnalyzer(stream);

          // Switch to microphone icon immediately after permission granted
          const questionIcon = document.getElementById("question-icon");
          const micIcon = document.getElementById("mic-icon");
          if (questionIcon) questionIcon.style.display = "none";
          if (micIcon) micIcon.style.display = "block";

          // Validate credentials before initializing
          console.log("=== Vapi Initialization Debug ===");
          console.log("Step 1: Validating credentials");
          console.log("PublicKey present:", !!publicKey);
          console.log("PublicKey type:", typeof publicKey);
          console.log("PublicKey length:", publicKey ? publicKey.length : 0);
          console.log("PublicKey preview:", publicKey ? `${publicKey.substring(0, 8)}...${publicKey.substring(publicKey.length - 4)}` : "N/A");
          console.log("AssistantId present:", !!assistantId);
          console.log("AssistantId type:", typeof assistantId);
          console.log("AssistantId value:", assistantId);
          console.log("AssistantId length:", assistantId ? assistantId.length : 0);

          if (!publicKey || !assistantId) {
            console.error("Missing credentials:", {
              publicKey: !!publicKey,
              assistantId: !!assistantId,
            });
            throw new Error(
              "Vapi credentials are missing. Please set PUBLIC_VAPI_PUBLIC_KEY and PUBLIC_VAPI_ASSISTANT_ID."
            );
          }

          // Additional validation - ensure assistantId is not just whitespace
          if (
            typeof assistantId !== "string" ||
            assistantId.trim().length === 0
          ) {
            console.error("Invalid assistantId:", assistantId);
            throw new Error(
              "Assistant ID is invalid or empty. Please check your PUBLIC_VAPI_ASSISTANT_ID environment variable."
            );
          }

          const trimmedAssistantId = assistantId.trim();
          console.log("Step 2: Credentials validated");
          console.log("Trimmed AssistantId:", trimmedAssistantId);
          console.log("Trimmed AssistantId length:", trimmedAssistantId.length);

          // Initialize Vapi
          try {
            // Create error handler that properly logs the error
            const handleError = function (error) {
              console.error("=== Vapi Error Handler ===");
              console.error("Vapi error event:", error);
              console.error("Error type:", typeof error);
              console.error("Error constructor:", error?.constructor?.name);
              
              // Try to extract error details
              let errorMessage = "Unknown error";
              if (error && typeof error === "object") {
                errorMessage =
                  error.message || error.error || JSON.stringify(error);
                
                // Log all error properties
                console.error("Error object properties:", Object.keys(error));
                console.error("Error object values:", error);
                
                // Check for specific error types
                if (error.type) {
                  console.error("Error type:", error.type);
                }
                if (error.stage) {
                  console.error("Error stage:", error.stage);
                }
                if (error.context) {
                  console.error("Error context:", error.context);
                }
                if (error.error) {
                  console.error("Nested error:", error.error);
                  if (typeof error.error === 'object') {
                    console.error("Nested error keys:", Object.keys(error.error));
                    if (error.error.message) {
                      console.error("Nested error message:", error.error.message);
                    }
                    if (error.error.status) {
                      console.error("Nested error status:", error.error.status);
                    }
                    if (error.error.statusText) {
                      console.error("Nested error statusText:", error.error.statusText);
                    }
                  }
                }
                if (error.message) {
                  console.error("Error message:", error.message);
                }
              } else if (error) {
                errorMessage = String(error);
              }

              console.error("Vapi error details summary:", {
                message: errorMessage,
                error: error,
                type: typeof error,
                keys:
                  error && typeof error === "object"
                    ? Object.keys(error)
                    : null,
              });
              
              // Check for 403/authentication errors
              if (errorMessage.includes('403') || errorMessage.includes('Forbidden')) {
                console.error("=== 403 Forbidden Error Detected ===");
                console.error("This usually means:");
                console.error("1. The API key (publicKey) is invalid or expired");
                console.error("2. The API key doesn't have permission to use this assistant");
                console.error("3. The assistant ID doesn't belong to the account associated with the API key");
                console.error("4. The API key might be a public key that needs different permissions");
                console.error("PublicKey used:", publicKey ? `${publicKey.substring(0, 8)}...${publicKey.substring(publicKey.length - 4)}` : "N/A");
                console.error("AssistantId used:", assistantId);
              }

              isActive = false;
              button.classList.remove("active");
              button.setAttribute("aria-label", "Start voice chat");
              button.disabled = false;
              button.style.opacity = "1";

              // Switch back to question mark icon
              const questionIcon = document.getElementById("question-icon");
              const micIcon = document.getElementById("mic-icon");
              if (questionIcon) questionIcon.style.display = "block";
              if (micIcon) micIcon.style.display = "none";

              // Show user-friendly error
              alert("Voice chat error: " + errorMessage);

              if (vapiInstance) {
                try {
                  vapiInstance.stop?.();
                } catch (e) {
                  // Ignore cleanup errors
                }
                vapiInstance = null;
              }
            };

            // Vapi constructor takes: apiToken, apiBaseUrl, dailyCallConfig, dailyCallObject
            // Use empty config to avoid function cloning issues - we'll use event listeners instead
            console.log("Step 3: Creating Vapi instance");
            console.log("Vapi constructor:", typeof Vapi);
            console.log("Calling new Vapi() with:");
            console.log("  - apiToken (publicKey):", publicKey ? `${publicKey.substring(0, 8)}...${publicKey.substring(publicKey.length - 4)}` : "N/A");
            console.log("  - apiBaseUrl: undefined (using default)");
            console.log("  - dailyCallConfig: {}");
            
            vapiInstance = new Vapi(
              publicKey, // apiToken
              undefined, // apiBaseUrl (use default)
              {}, // Empty dailyCallConfig - functions can't be cloned by Daily.co
              undefined // dailyCallObject
            );
            
            console.log("Step 4: Vapi instance created");
            console.log("Vapi instance:", vapiInstance);
            console.log("Vapi instance type:", typeof vapiInstance);
            console.log("Vapi instance methods:", vapiInstance ? Object.keys(vapiInstance).filter(key => typeof vapiInstance[key] === 'function') : []);
            console.log("Has start method:", vapiInstance && typeof vapiInstance.start === 'function');
            console.log("Has call method:", vapiInstance && typeof vapiInstance.call === 'function');
            console.log("Has on method:", vapiInstance && typeof vapiInstance.on === 'function');

            // Use event listeners instead of callbacks to avoid cloning issues
            // Daily.co tries to clone functions in callbacks, causing DataCloneError
            if (vapiInstance && typeof vapiInstance.on === "function") {
              // Call start success event (fires when call actually starts)
              vapiInstance.on("call-start-success", function () {
                console.log("Vapi call started successfully");
                isActive = true;
                button.classList.add("active");
                button.setAttribute("aria-label", "End voice chat");
                button.disabled = false;
                button.style.opacity = "1";
                // Switch to microphone icon
                const questionIcon = document.getElementById("question-icon");
                const micIcon = document.getElementById("mic-icon");
                if (questionIcon) questionIcon.style.display = "none";
                if (micIcon) micIcon.style.display = "block";
              });

              // Also listen to call-start for immediate feedback
              vapiInstance.on("call-start", function () {
                console.log("Vapi call starting...");
                // Icon already switched before start() was called
              });

              // Call end event
              vapiInstance.on("call-end", function () {
                console.log("Vapi call ended");
                isActive = false;
                button.classList.remove("active");
                button.setAttribute("aria-label", "Start voice chat");
                button.disabled = false;
                button.style.opacity = "1";
                // Switch back to question mark icon
                const questionIcon = document.getElementById("question-icon");
                const micIcon = document.getElementById("mic-icon");
                if (questionIcon) questionIcon.style.display = "block";
                if (micIcon) micIcon.style.display = "none";
                // Stop audio analyzer
                stopAudioAnalyzer();
                if (vapiInstance) {
                  vapiInstance = null;
                }
              });

              // Error event
              vapiInstance.on("error", handleError);
            }

            // Start the call with proper error handling
            // start() method signature: start(assistant, assistantOverrides, squad, workflow, workflowOverrides, options)
            try {
              // Switch to microphone icon before starting call
              const questionIconEl = document.getElementById("question-icon");
              const micIconEl = document.getElementById("mic-icon");
              if (questionIconEl) questionIconEl.style.display = "none";
              if (micIconEl) micIconEl.style.display = "block";

              if (typeof vapiInstance.start === "function") {
                // Ensure assistantId is a valid string before calling start
                const validAssistantId =
                  assistantId && typeof assistantId === "string"
                    ? assistantId.trim()
                    : assistantId;

                console.log("=== Starting Vapi Call ===");
                console.log("Step 5: Preparing to call vapiInstance.start()");
                console.log("AssistantId validation:", {
                  original: assistantId,
                  trimmed: validAssistantId,
                  type: typeof validAssistantId,
                  length: validAssistantId?.length || 0,
                  isEmpty: !validAssistantId || validAssistantId === "",
                });

                if (!validAssistantId || validAssistantId === "") {
                  throw new Error(
                    "Assistant ID is empty or invalid. Value: " +
                      String(assistantId)
                  );
                }

                console.log("Step 6: Calling vapiInstance.start()");
                console.log("Method:", typeof vapiInstance.start);
                console.log("Parameter (assistantId):", validAssistantId);
                console.log("Parameter type:", typeof validAssistantId);
                console.log("Parameter length:", validAssistantId.length);
                console.log("Vapi instance before start:", vapiInstance);
                
                // Pass assistantId as the first parameter to start()
                try {
                  const startResult = vapiInstance.start(validAssistantId);
                  console.log("Step 7: vapiInstance.start() called successfully");
                  console.log("Start result:", startResult);
                  console.log("Start result type:", typeof startResult);
                  if (startResult && typeof startResult.then === 'function') {
                    console.log("Start returned a Promise");
                    startResult
                      .then((result) => {
                        console.log("Start Promise resolved:", result);
                      })
                      .catch((err) => {
                        console.error("Start Promise rejected:", err);
                      });
                  }
                } catch (startCallError) {
                  console.error("Error thrown by vapiInstance.start():", startCallError);
                  console.error("Error name:", startCallError?.name);
                  console.error("Error message:", startCallError?.message);
                  console.error("Error stack:", startCallError?.stack);
                  throw startCallError;
                }
              } else if (typeof vapiInstance.call === "function") {
                console.log("Calling Vapi...");
                if (!assistantId || assistantId.trim() === "") {
                  throw new Error("Assistant ID is empty or invalid");
                }
                vapiInstance.call(assistantId.trim());
              } else {
                throw new Error(
                  "Vapi instance does not have start() or call() method"
                );
              }
            } catch (startError) {
              console.error("Error starting Vapi call:", startError);
              // Switch back to question mark on error
              const questionIconEl = document.getElementById("question-icon");
              const micIconEl = document.getElementById("mic-icon");
              if (questionIconEl) questionIconEl.style.display = "block";
              if (micIconEl) micIconEl.style.display = "none";
              handleError(startError);
              throw startError;
            }
          } catch (initError) {
            console.error("Vapi initialization error:", initError);
            button.disabled = false;
            button.style.opacity = "1";
            alert(
              "Failed to initialize voice chat: " +
                (initError.message || "Unknown error")
            );
          }
        } catch (error) {
          console.error("Error:", error);
          button.disabled = false;
          button.style.opacity = "1";
          // Stop audio analyzer on error
          stopAudioAnalyzer();

          if (error.name === "NotAllowedError") {
            alert("Please allow microphone access to use voice chat.");
          } else if (error.message && error.message.includes("constructor")) {
            alert(
              "Voice chat is temporarily unavailable. Please refresh the page."
            );
          } else {
            alert(
              "Error accessing microphone. Please check your browser settings."
            );
          }
        }
      }
    });
  }

  // Initialize button handler (SDK will be loaded lazily on first click)
  if (publicKey && assistantId) {
    initializeVapi();
  } else {
    // Disable button if credentials are missing
    const button = document.getElementById("vapi-voice-button");
    if (button) {
      button.style.opacity = "0.5";
      button.style.cursor = "not-allowed";
      button.disabled = true;
      button.setAttribute(
        "title",
        "Voice chat unavailable - credentials missing"
      );
    }
  }
</script>

<style>
  .vapi-widget-container {
    position: fixed;
    z-index: 9999;
  }

  /* Position classes - using explicit CSS since Tailwind is not configured */
  .vapi-widget-container.bottom-right {
    bottom: 24px;
    right: 24px;
  }

  .vapi-widget-container.bottom-left {
    bottom: 24px;
    left: 24px;
  }

  .vapi-widget-container.top-right {
    top: 24px;
    right: 24px;
  }

  .vapi-widget-container.top-left {
    top: 24px;
    left: 24px;
  }

  .vapi-voice-button {
    position: relative;
    width: 64px;
    height: 64px;
    border-radius: 50%;
    background: transparent;
    border: 2px solid rgba(255, 255, 255, 0.8);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow:
      0 4px 20px rgba(102, 126, 234, 0.4),
      0 0 0 0 rgba(102, 126, 234, 0.5);
    transition: all 0.3s ease;
    padding: 0;
  }

  .vapi-voice-button:hover {
    transform: scale(1.1);
    border-color: rgba(255, 255, 255, 1);
    box-shadow:
      0 6px 30px rgba(102, 126, 234, 0.6),
      0 0 0 0 rgba(102, 126, 234, 0.7);
  }

  .vapi-voice-button:active {
    transform: scale(0.95);
  }

  .vapi-voice-button.active {
    background: transparent;
    border-color: rgba(245, 87, 108, 0.8);
    box-shadow:
      0 4px 20px rgba(245, 87, 108, 0.4),
      0 0 0 0 rgba(245, 87, 108, 0.5);
    animation: pulse-ring 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  .vapi-icon {
    width: 28px;
    height: 28px;
    color: white;
    z-index: 1;
    position: relative;
  }

  /* Question mark uses fill */
  #question-icon {
    fill: currentColor;
  }

  /* Microphone uses stroke */
  #mic-icon {
    stroke: currentColor;
    fill: none;
  }

  /* Icon state management */
  .icon-default {
    display: block;
  }

  .icon-active {
    display: none;
  }

  .vapi-voice-button.active .icon-default {
    display: none;
  }

  .vapi-voice-button.active .icon-active {
    display: block;
    animation: mic-pulse 1.5s ease-in-out infinite;
  }

  @keyframes mic-pulse {
    0%,
    100% {
      transform: scale(1);
      opacity: 1;
    }
    50% {
      transform: scale(1.1);
      opacity: 0.8;
    }
  }

  .vapi-pulse {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.3);
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  @keyframes pulse {
    0%,
    100% {
      opacity: 1;
      transform: scale(1);
    }
    50% {
      opacity: 0.5;
      transform: scale(1.1);
    }
  }

  @keyframes pulse-ring {
    0% {
      box-shadow:
        0 4px 20px rgba(245, 87, 108, 0.4),
        0 0 0 0 rgba(245, 87, 108, 0.7);
    }
    50% {
      box-shadow:
        0 4px 20px rgba(245, 87, 108, 0.4),
        0 0 0 10px rgba(245, 87, 108, 0);
    }
    100% {
      box-shadow:
        0 4px 20px rgba(245, 87, 108, 0.4),
        0 0 0 0 rgba(245, 87, 108, 0);
    }
  }

  /* Audio level meter */
  .audio-level-meter {
    position: absolute;
    bottom: -40px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: flex-end;
    justify-content: center;
    gap: 3px;
    height: 30px;
    width: 100%;
    pointer-events: none;
  }

  .level-bars {
    display: flex;
    align-items: flex-end;
    justify-content: center;
    gap: 3px;
    height: 100%;
  }

  .level-bar {
    width: 4px;
    min-height: 4px;
    background: linear-gradient(
      to top,
      rgba(102, 126, 234, 1) 0%,
      rgba(102, 126, 234, 0.8) 50%,
      rgba(255, 255, 255, 0.6) 100%
    );
    border-radius: 2px;
    transition:
      height 0.1s ease,
      opacity 0.2s ease;
    opacity: 0.3;
    height: 4px;
  }

  .vapi-voice-button.active ~ .audio-level-meter .level-bar {
    background: linear-gradient(
      to top,
      rgba(245, 87, 108, 1) 0%,
      rgba(245, 87, 108, 0.8) 50%,
      rgba(255, 255, 255, 0.6) 100%
    );
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .vapi-voice-button {
      width: 56px;
      height: 56px;
    }

    .vapi-icon {
      width: 24px;
      height: 24px;
    }

    .audio-level-meter {
      bottom: -35px;
    }

    .level-bar {
      width: 3px;
      gap: 2px;
    }
  }
</style>
